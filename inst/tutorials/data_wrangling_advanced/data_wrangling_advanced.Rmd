---
title: "tidyverse advanced"
author: "michelle kang"
date: "07/02/2020"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
library(tidyverse)
```

## Load packages
Let's first load the tidyverse package into our environment

**R v3.4 or newer**
```{r message=FALSE}
library(tidyverse)
library(educer)
```

## Refresher 

```{r echo=FALSE, results=FALSE}
pdat <- geochemicals
temp <- pdat %>% 
  select(Depth, CTD_O2) %>% 
  filter(Depth == 100) %>% 
  rename(Oxygen = CTD_O2) %>% 
  mutate(Oxygen = Oxygen*32) %>%
  filter(!is.na(Oxygen))
```

1. Select the Depth and CTD_O2 variables from geochemicals dataset
2. Filter to 100 m samples
3. Rename the O2 variable to `Oxygen` using rename
4. Transform Oxygen from micromoles/L to micrograms/L using mutate (multiply Oxygen by 32)
    - You should now have a [`r dim(temp)`] data frame.
5. Calculate the mean and standard deviation of Oxygen in micrograms/L for this subset of data.

This should result in `r mean(temp$Oxygen)` $\pm$ `r sd(temp$Oxygen)`

```{r refresher_exercise, exercise = TRUE, exercise.lines = 5}
```

Write a one line command that filters the geochemicals dataset for all geochemical mean values 

```{r refresher_startswith, exercise = TRUE, exercise.lines = 5}
```

## Join Tables 

Dyplr has built in functions to quickly join two tables. In this tutorial we will be focusing on Inner Join. Inner join takes in two tables, x and y, and return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.

for example, a table x:
```{R echo=FALSE, warning=FALSE, message=FALSE}
metadata <- read_tsv("Saanich_metadata.txt", col_names = TRUE)
head(metadata)
```

and a table y:
```{r echo=FALSE, warning=FALSE, message=FALSE}
otu_data <- read_tsv("Saanich_OTU.txt", col_names = TRUE)
otu_data <- rename(otu_data, sample = X1)
head(otu_data)
```

can be joined by their mutual column "sample" like this:
```{r warning=FALSE, message=FALSE}
metadata <- read_tsv("Saanich_metadata.txt", col_names = TRUE)
otu_data <- read_tsv("Saanich_OTU.txt", col_names = TRUE)
otu_data <- rename(otu_data, sample = X1)
otu_metadata <- inner_join(metadata, otu_data, by = "sample")
otu_metadata
```

as you may have noticed, this is how the "Saanich_OTU_Metadata.csv" file from the introductory tutorial was generated. 

we will select the first 15 columns to work with fewer OTUs:
```{R}
subset_otu_metadata <- select(otu_metadata, 1:15)
```

## Pivoting Data

`pivot_longer` and `pivot_wider` are verbs that convert wide and long data, which are two different formats for a data frame. Wide data is where each variable is given its own column. Narrow data is where one column contains all of the variable names, and another column contains all of the values of these variables.

For example, this wide data

```{r, echo=FALSE}
set.seed(123)
wide <- data.frame(
  sample_ID = c(1, 2, 3, 4),
  year_2015 = runif(4, 0, 1) %>% round(3),
  year_2016 = runif(4, 0.2, 1.2) %>% round(3),
  year_2017 = runif(4, 0.5, 1.5) %>% round(3)
)
wide
```

contains the same information as this long data.
```{r echo=FALSE}
pivot_longer(wide, cols = c("year_2015", "year_2016", "year_2017"), names_to ="Year", values_to = "Value") %>% arrange(sample_ID)
```

Our data is in the wide format. Observe that each variable is given its own column.
```{r}
subset_otu_metadata
```

Some R functions work better with wide data and others work better with long data. `pivot_longer` and `pivot_wider` are two functions from the tidyr package that enable easy conversion between the formats. The first will merge all specified columns in the "cols" parameter into one column containing all of the variable names (specified by the "names_to" parameter) and another column containing all of the values (specified by the values_to parameter). The second function will "spread" your long data into the wide data format. 

Here, we convert our data from wide to long format using `pivot_longer()`.
```{r}
long_dat <-
  pivot_longer(
    subset_otu_metadata,
    cols = c("NO3_uM", "NO2_uM", "N2O_uM", "NH4_uM", "H2S_uM", "O2_uM", "PO4_uM", "SiO2_uM", "CH4_nM"),
     names_to = "Chemical",
     values_to = "Concentration",
  )

long_dat
```

We can undo this by spreading our data from long to wide format. Arguements for `pivot_wider` are: the dataframe that we want to convert from long to wide, the column(s) that you want to convert into multiple columns in the "names_from" parameter and their corresponding values in the "values_from" parameter. 
```{r}
wide_dat <- pivot_wider(long_dat, names_from = "Chemical", values_from = "Concentration")
wide_dat
```

long data is more frequently used in plotting with ggplot.
