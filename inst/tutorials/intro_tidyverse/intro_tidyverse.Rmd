---
title: "Introduction to the R tidyverse"
author: "Gil J. B. Henriques, Kim Dill-McFarland and Kris Hong.<br>
        A tutorial by [ECOSCOPE](http://ecoscope.ubc.ca/) at UBC."
date: "version `r format(Sys.time(), '%B %d, %Y')`"
description: In-depth description will follow.
output: 
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
# General learnr setup
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
library(educer)
# Helper function to set path to images to "/images" etc.
setup_resources()

# Tutorial specific setup
library(tidyverse) # Suite of packages for data manipulation and visualization
library(lubridate) # Special formatting for dates within data
library(cowplot) # Multi-panel figures
library(readr)

```

## Introduction
In this tutorial, we will learn to manipulate and plot real-world data using the [tidyverse](https://www.tidyverse.org/), a collection of R packages for data analysis and visualization.

You will learn how to:

* Create subsets of rows or columns from data frames using dplyr,
* Change your data frames between wide and long formats,
* Create various types of graphics,
* Modify the various features of a graphic, and
* Save your graphic in various formats

This comprehensive introduction to the tidyverse is ideal for beginners but assumes some prior experience with R (such as that in our [Introduction to R and RStudio tutorial](https://github.com/EDUCE-UBC/educer/tree/master/inst/tutorials/r_and_rstudio_ws)).

### How to follow the tutorial

Throughout the tutorial, you will encounter a number of coding exercises. Follow the instructions to complete the code in the code exercise window ![](images/one.png){width=0.3in} and then click on the “Run Code” button to see the results ![](images/two.png){width=0.3in}. You can reset the exercise if you get stuck ![](images/three.png){width=0.3in}, or can get hints or the solution ![](images/four.png){width=0.3in}.

![](images/code_exercise_small.png){width=5in}

You can leave this tutorial at any time: it will remember your progress when you return.

### Data description

We will work with real-world data collected as part of an ongoing oceanographic time series program in Saanich Inlet, a seasonally anoxic fjord on the East coast of Vancouver Island, British Columbia:

![](images/saanich_inlet_map.png){width=4in}

The figure shows a map of Saanich Inlet indicating conventional sample collection stations (S1-S9). The data used in this tutorial (sourced from S3) include various geochemical measurements at many depths in Saanich Inlet. Samples were taken approximately monthly from 2006 to 2014, though there is much missing data to contend with.

During this tutorial, the data are accessible as a data frame called `geochemicals`. In the interactive code box below, use the function `head` to peak at the first few rows of this data frame:

```{r geochemicals, exercise = TRUE}
head(<name_of_the_data_frame>)
```

```{r geochemicals-solution}
head(geochemicals)
```

For more details about these data, see [Hallam SJ *et al*. 2017. Sci Data 4: 170158](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5663219/) "Monitoring microbial responses to ocean deoxygenation in a model oxygen minimum zone". More detailed information on the environmental context and time series data can be found in [Torres-Beltrán M *et al*. 2017. Sci Data 4: 170159.](https://www.nature.com/articles/sdata2017159) "A compendium of geochemical information from the Saanich Inlet water column".

### Loading packages

The [tidyverse](https://www.tidyverse.org/) is a collection of R packages. Packages expand R's capabilities by providing additional functions. Some tidyverse packages that we will use in this tutorial are: dplyr (for data manipulation; pronounced *dee-plier*), tidyr (for rearranging data frames), and ggplot2 (for data visualization).  We will also use the packages lubridate (for working with dates) and cowplot (for multi-panel figures).

When you work in your own projects, always load the packages you need at the top of your script. You can load each one of the tidyverse packages individually, but since they are often used together, you can also download and load the entire suite of tidyverse packages at once. In the future, you can use the code below to load all of the R packages we will use in this tutorial. 

```{r echo = TRUE, message = FALSE}
library(tidyverse) # Suite of packages for data manipulation and visualization
library(lubridate) # Special formatting for dates within data
library(cowplot) # Multi-panel figures
```

Keep in mind that to use packages in a script, these packages *must already be installed* in your computer (see the [Introduction to R and RStudio tutorial](https://github.com/EDUCE-UBC/educer/tree/master/inst/tutorials/r_and_rstudio_ws) for more details about installing packages and working with scripts).

## Data in R

This section is a reminder of how to manipulate data in base R. If *all* of these concepts are completely new to you, consider doing our [Introduction to R and RStudio tutorial](https://github.com/EDUCE-UBC/educer/tree/master/inst/tutorials/r_and_rstudio_ws). If you feel comfortable extracting columns from data frames and subsetting vector elements by index or by logical conditions, feel free to skip ahead to the next section ("Data wrangling").

### Data types and structures

A variable's *type* is the kind of information that can be stored in that variable. 

* **Numeric** variables are numbers (e.g., `1`, `1.41`, `pi`)
* **Character** variables are alphanumeric strings and are always surrounded by quotes `"` or apostrophes `'` (e.g., `"x"`, `"date"` `"1.41"`, `"TRUE"`)
* **Logical** variables can only have two possible values: `TRUE` or `FALSE`.

A variable can contain one or more elements of the above data types. Variables can have different *structures*, of which the most important are the *vector* and the *data frame*.

* A **vector** is a one-dimensional set of elements with the same type. A variable with a single element is also a vector (of length 1)
* A **data frame** is two-dimensional (i.e., it is like a table). Each column in a data frame is like a vector

Identifying what type and structure of data you are working with is important because certain functions can only be applied to certain types/structures.

### Subsetting data in base R

#### Subsetting columns from a data frame

In base R, we can create a vector equal to a data frame's column using the `$` notation. In the box below, create a vector called `oxygen` equal to the column `Mean_O2` in our `geochemicals` data frame:

```{r extract_column, exercise = TRUE}
oxygen <- <data_frame>$<column_name> # create vector
oxygen # print vector
```

```{r extract_column-solution}
oxygen <- geochemicals$Mean_O2 # create vector
oxygen # print vector
```

```{r setup_oxygen, include = FALSE}
oxygen <- geochemicals$Mean_O2
```

That the newly created `oxygen` vector is of type numeric: it contains numbers. Some of its elements are `NA`: this is not a character string (note that it is not surrounded by quotation marks), but rather R's symbol for indicating missing data (it stands for "not available").

#### Subsetting vetors by index

We can further subset these data by pulling out specific measurements using the square bracket `[ ]` notation. In the box below, subset the elements 64, 66, and 69 through 75 of the `oxygen` vector. If you need help, use the Hint button.

```{r subset_elements, exercise = TRUE, exercise.setup = "setup_oxygen"}
oxygen[<vector_of_element_indices>] 
```

```{r subset_elements-hint-1}
oxygen <- oxygen[c(<indices>)] 
```

```{r subset_elements-hint-2}
oxygen <- oxygen[c(64, 66, 69:75)] 
```

Note that what we just did is equivalent from first extracting rows 64, 66, and 69 through 75 of the `geochemicals` data frame, and then subsetting the `Mean_O2` column.

#### Subsetting vectors by condition

As we saw above, there are a lot of missing data in the `oxygen` vector. Let's say we want to find all `NA` elements. This can be done using the `is.na()` function, which returns `TRUE` when the function's argument is equal to `NA`. In the box below, use this function to print a logical vector that is `TRUE` when `oxygen` is `NA`:

```{r is_na, exercise = TRUE, exercise.setup = "setup_oxygen"}
is.na(<vector>)
```

```{r is_na-solution}
is.na(oxygen)
```

Let's say we want to subset `oxygen` to include only non-NA values. The first thing we need is the opposite of the vector we just printed: a vector that is `TRUE` whenever `oxygen` is NOT `NA`. When we place the operator `!` in front of a logical vector, it reverses the value of all of its elements: from `TRUE` to `FALSE` and vice-versa. In the box below, combine the `!` operator and the `is.na()` function to create a vector that is `TRUE` whenever `oxygen` is not `NA`. Call this vector `not_na`:

```{r na_values, exercise = TRUE, exercise.setup = "setup_oxygen"}
not_na <- <your_work_here> # create vector
not_na # print vector
```

```{r na_values-solution}
not_na <- !is.na(oxygen) # create vector
not_na # print vector
```

```{r setup_na, include = FALSE}
oxygen <- geochemicals$Mean_O2
not_na <- !is.na(oxygen)
```

You can then use the logical vector `not_na` to subset the `oxygen` vector (just like you would use a vector of indices) using the square bracket notation from above. In the box below, let's re-define `oxygen` so as to contain only non-NA values:

```{r oxygen_no_na, exercise = TRUE, exercise.setup = "setup_na"}
oxygen <- oxygen[<logical_vector_here>]
```

```{r oxygen_no_na-solution}
oxygen[not_na] # one possible solution
oxygen[!is.na(oxygen)] # another possible solution
```

```{r setup_redefine_oxygen, include = FALSE}
oxygen <- geochemicals$Mean_O2
not_na <- !is.na(oxygen)
oxygen <- oxygen[not_na]
```

**Note:** that there are multiple ways of performing this task. Click the Solution button on top of the exercise box to ensure that you understand them.

What we just did was an example of *subsetting by condition*: instead of choosing (by index) which of the hundreds of elements of oxygen to keep, we chose to keep only those elements that obey a specific *logical condition* (in this case, the condition of not being `NA`).

Subsetting by condition is particularly powerful when using conditional statements. Here are some examples of conditional statements:

* `a == b` returns `TRUE` when `a` matches `b`
* `a != b` returns `TRUE` when `a` does not match `b`
* `a > b` returns `TRUE` when `a` is greater than `b`
* `a <= b` returns `TRUE` when `a` is smaller than or equal to `b`

In the box below, use a conditional statement to create and print a logical vector called `high_O2`, which is `TRUE` only when the `oxygen` measurement is above 400:

```{r conditional_statements, exercise = TRUE, exercise.setup = "setup_redefine_oxygen"}
high_O2 <- <conditional_statement_here> # create logical vector
high_O2 # print logical vector
```

```{r conditional_statements-solution}
high_O2 <- oxygen > 400
high_O2
```

```{r setup_high_O2, include = FALSE}
oxygen <- geochemicals$Mean_O2
not_na <- !is.na(oxygen)
oxygen <- oxygen[not_na]
high_O2 <- oxygen > 400
```

Now, use the logical vector `high_O2` to subset `oxygen`, using the square bracket notation, so as to return only those values that are above 400:

```{r subset_logical, exercise = TRUE, exercise.setup = "setup_high_O2"}
oxygen[<logical_vector_here>]
```

```{r subset_logical-solution}
oxygen[high_O2] # one possible solution
oxygen[oxygen > 400] # another possible solution
```

You can also combine multiple conditions. The logical **AND** operator `a & b` returns `TRUE` when both `a` and `b` are themselves `TRUE`. The logical **OR** operator `a | b` returns `TRUE` when *at least* one of `a` and `b` are themselves `TRUE`. In the box below, subset `oxygen` to return only the cases when the measurement is larger than 20 but smaller or equal to 120:

```{r subset_logical_and, exercise = TRUE, exercise.setup = "setup_high_O2"}
oxygen[<logical_vector_here>]
```

```{r subset_logical_and-solution}
oxygen[oxygen > 20 & oxygen <= 120]
```

Another useful logical operator is the `%in%` operator: `a %in% b` returns `TRUE` if the value of `a` is one of the elements in the vector `b`. In the box below, find out whether there is any measurement of `oxygen` that is *exactly* equal to `3.5`:

```{r in_operator, exercise = TRUE, exercise.setup = "setup_high_O2"}
<value> %in% <vector>
```

```{r in_operator-solution}
3.5 %in% oxygen
```

#### Exercise: subsetting data
In the box below, use the first 16 elements of the `Depth` column to:

1. Find the indices where depth is greater or equal to 0.055
2. Check if the value 0.111 is in the depth data
3. Find values of depth that are less than 0.060 *or* greater than 0.140

```{r subsetting_exercises, exercise = TRUE}

```

```{r subsetting_exercises-solution}
depth <- geochemicals$Depth

depth >= 0.055 # exercise 1
0.111 %in% depth # exercise 2
depth[depth < 0.06 | depth > 0.14] # exercise 3
```

## Data wrangling

"Wrangling" is the process of manipulating and transforming "raw" data into a more accessible format that you can use for analysis or visualization. 



