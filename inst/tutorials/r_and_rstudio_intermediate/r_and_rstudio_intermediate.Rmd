---
title: "Intermediate R and RStudio"
author: "Cathy Yan"
date: "version `r format(Sys.time(), '%B %d, %Y')`"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: [DESCRIPTION]
---

```{r setup, include = FALSE}
# General learnr setup
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
library(educer)
# Helper function to set path to images to "/images" etc.
setup_resources()

# Tutorial specific setup
library(dplyr)
library(readr)
library(tidyverse)
```

## Learning objectives

Here's what you'll learn from each section of this tutorial:

Loops in R:

- Explain the mechanisms of for and while loops
- Implement for and while loops
- Recognize and understand how nested loops work

Conditionals in R:

- Write and evaluate and/or statements
- Identify the components of if/else statements
- Implement conditionals within loops

Functions in R:

- Write functions that operate on arguments
- Understand the role of helper functions
- Implement helper functions

Manipulating Data Frames:

- Implement the pipe operator
- Use the `select()`, `filter()`, and `mutate()` functions appropriately
- Operate on individual columns within a data frame
- Change the data type of columns in a data frame
- Replace NAs in a vector or data frame

Other ideas: Tidying data, joining data frames, loading in data from an external source

## Review

Before proceeding, complete the five questions below reviewing content from Introduction to R and RStudio Fundamentals. If any of the concepts seem unfamiliar, please revisit the previous tutorial.

```{r using-libraries, echo=FALSE}
quiz(question("In no particular order, which actions are required before using functions from a new package?",
      answer("Install the package", correct=TRUE),
      answer("Download vignettes"),
      answer("Load the package", correct=TRUE),
      answer("Install dependencies"))
)
```

Pull up the help page for the function `quantile()`.

```{r q-help, exercise=TRUE}
# your code here
```

```{r q-help-solution}
?quantile
```

```{r review, echo=FALSE}
quiz(
  question("What types of arguments can be passed to `quantile()`?",
    answer("Logical", correct=TRUE),
    answer("Numeric", correct=TRUE),
    answer("Logical Vector"),
    answer("Numeric Vector", correct=TRUE),
    answer("Text"))
)
```

Create a vector with the numbers 9, 27, 15, 74, 36, 4, and 49 and assign it to the variable `x`. Calculate the quantiles for `x`.

```{r q-vector, exercise=TRUE}
# your code here
```

```{r q-vector-hint-1}
x <- c(9, 27, 15, 74, 36, 4, 49)
```

```{r q-vector-solution}
x <- c(9, 27, 15, 74, 36, 4, 49)
quantile(x)
```

```{r q-type1, echo=FALSE}
quiz(
  question("What is the 75% quantile for `x`?",
    answer("36"),
    answer("50.25"),
    answer("42.5", correct=TRUE))
)
```

## Writing Function in R

In the previous tutorial, you learned how to use preexisting functions. Now, you will write your own.

### Why Write Functions?

When you're performing the same set of transformations on the same kinds of inputs, you should consider writing a function to automate the task. Functions make your code:

- Reproducible
- Concise
- Easier to understand

### Syntax for Writing Functions

Functions take on the following form:

```{r fun-ex, eval=FALSE, error=TRUE}
myfunction <- function(arg1, arg2){
  myoutput <- myaction(arg1, arg2)
  return(myoutput)
}
```

Let's break down each component while writing a function that divides numbers by two:

#### Naming your function

In the previous tutorial, you used the function `sum()` to add a vector of numbers. You used the word "sum", the function's name, to call for it. Similarly, your own function also needs a name to be used. In our example above, the function's name is "myfunction", and you would call for it by typing `myfunction()`.

#### Using the `function()` function

Defining a function uses the same syntax as defining a variable, so how does R tell them apart? Using the `function()` function identifies your function name as such rather than as a variable.

To begin writing our function, which we'll name `halve()`, fill in the blanks below:

```{r fun-start, exercise = TRUE, eval=FALSE, error=TRUE}
... <- ...(){}
```

```{r fun-start-solution}
halve <- function(){}
```

#### Setting arguments

In the review quiz, you passed a vector of numbers as an argument to the function `quantile()`. Similarly, you'll need to be able to pass arguments to you own function. To do this, you'll need to name each of your arguments, and list them within the `function()` function. In the example above, we have two arguments: `arg1` and `arg2`. 

Right now, in order for the function to work, the user will need to provide both arguments. However, you can also set default values for arguments. The syntax is as follows:

```{r fun-ex2, eval=FALSE, error=TRUE}
myfunction <- function(arg1, arg2 = 5){
  myoutput <- myaction(arg1, arg2)
  return(myoutput)
}
```

Now, the user is only required to provide `arg1`. If they don't provide `arg2`, the function will run using the default value of 5. If `arg2` is provided, the input value overrides the default (i.e. if the user specifies a value of 7 for `arg2`, the function will use that instead of 5, the default).

For our function, we'll only need one argument, which we'll call `num`. It doesn't make sense for it to have a default value since there's no universal number people want to halve, so we won't include one.

```{r fun-arg, exercise = TRUE, eval = FALSE, error = TRUE}
halve <- function(...){}
```

```{r fun-arg-solution}
halve <- function(num){}
```

#### Operating on arguments

The function's body is enclosed by curly braces. Within, the arguments are transformed through one or more operations. In this case, there is only one operation, `myaction()`, which acts upon both arguments. The output of `myaction()` is assigned to the variable `myoutput`. This variable assignment works in the same way as usual, except for one caveat: `myoutput` cannot be used outside of the function. You will not see it show up in your environment.

We want our function to halve, or divide by two, any number we provide. We'll name our output variable `half`.

```{r fun-act, exercise = TRUE, eval = FALSE, error = TRUE}
halve <- function(num){
  half <- ...
}
```

```{r fun-act-solution}
halve <- function(num){
  half <- num / 2
}
```

#### Returning outputs

When you define a variable normally, you need to call on the variable to see its value. Within functions, the sample principle applies. Although `myoutput` is assigned a value, `myfunction()` will not actually return it unless you explicitly tell it to do so. In this example, the `return()` function is used to accomplish this. Let's return `half`:

```{r fun-ret, exercise = TRUE, eval = FALSE, error = TRUE}
halve <- function(num){
  half <- num / 2
  ...
}
```

```{r fun-ret-solution}
halve <- function(num){
  half <- num / 2
  return(half)
}
```

### Helper Functions

Of course, all of the functions you'll need will be much more complex than `halve()`. In fact, some will be so complex that you'll need *helper functions* to complete the task. In the example below, we have a function that adds 5 to the average of a list of numbers:

```{r num-list, exercise = TRUE}
avg_minus_five <- function(num_list){
  output <- mean(num_list) + 5
  return(output)
}

list = c(1, 2, 3, 4, 5, 6)

answer <- avg_minus_five(list)
answer
```

Did you notice anything different with `avg_minus_five()` compared to `halve()`? In the former, we're using another function, `mean()`, inside of the function we wrote. Instead of writing code to calculate the average from scratch, we're using `mean()` to help us get to our desired output in a quicker and more concise way. In this case, `mean()` is our helper function.

### Rewriting Functions with Helper Functions

Let's walk through the process for writing and implementing a helper function. Below, we have a long function. Can you guess what it does?

```{r long-func, exercise = TRUE}
# flow control?
```

### Check Your Understanding



## Manipulating Data Frames

### Transforming Data

The functions you have implemented so far all perform operations on one piece of data at a time. For example, `halve()` takes a single number and divides it by two, but can it be used on columns in a data frame?

```{r df, include=FALSE}
grades <- data.frame(
  name = c("John", "Jane", "Charles", "Amy", "Joe"),
  score = c(30, 80, 65, 92, 73),
  passing = c(FALSE, TRUE, TRUE, TRUE, TRUE)
)
```

We're going to be using our dataset with students' grades from the last tutorial:

```{r df2, exercise=TRUE, exercise.setup="df"}
grades
```

Try to divide all of the students' grades by half using the `halve()` function. The `$` symbol is used to select columns from a data frame.

```{r halve-col, exercise = TRUE, error=TRUE, exercise.setup="df"}
halve <- function(num){
  half <- num / 2
  return(half)
}

halve(grades$score)
```

Every value in the column is halved without needing to be passed to the function one at a time. This is called vectorization, allowing you to work with vectors in a concise and efficient manner. 

Let's try to take this one step further. Below, we have a data frame tracking measurements for Jack's magical beanstalk. 

```{r stalk, include=FALSE}
measurements <- data.frame(
  hours = seq(1:6),
  height = c(0, 13, "not collected", 62, 87, "not collected"),
  circumference = c(0, 4, 11, 23, "not collected", 52),
  weight = c(0, "not collected", 25, 60, "not collected", 83)
)
```

```{r stalk2, exercise=TRUE, exercise.setup="stalk"}
measurements
```
What do you notice about the height, circumference, and weight columns? They're supposedly characters, but we know that's not right. As you may remember from the last tutorial, vectors can only hold one type of data. The "not collected" values forced R to treat the entire columns as being of type character due to coercion. Let's see what happens when we try to take the mean height:

```{r mean-height, exercise = TRUE, error = TRUE, exercise.setup="stalk"}
mean(measurements<select the height column>)
```

```{r mean-height-solution}
mean(measurements$height)
```

We're not particularly surprised by this result since `mean()` can't operate on characters, even if they look like numbers. We can try to convert all of our columns to type numeric using the `as.numeric()` function, which takes a vector and coerces its data into numbers. Non-numerical data like "not collected" gets turned to NAs. Every column is supposed to be numeric, so can we just pass the entire data frame as an argument?

```{r numer, exercise=TRUE, error=TRUE, exercise.setup="stalk"}
as.numeric(measurements)
```

Unfortunately, as.numeric can only convert one vector at a time, but writing the same code for all three columns is clumsy. Instead, we can use the `sapply()` function, which applies functions to columns in a data frame iteratively (one by one). Its basic syntax is:

```{r s-syntax, error=TRUE, eval=FALSE}
sapply(my_df, my_func)
```

Let's try applying the `as.numeric()` function to all columns in `measurements`.

```{r sapply, exercise=TRUE, error=TRUE, exercise.setup="stalk"}
num_measurements <- sapply(<name of df>, <name of function>) %>%
  as.data.frame()
num_measurements
```

```{r sapply-solution}
num_measurements <- sapply(measurements, as.numeric) %>%
  as.data.frame()
num_measurements
```

As expected, our columns are now of type numeric with the "not collected" values being replaced by NAs. 

We can also use `sapply()` with functions we write. Try halving all of the values in the data frame with the `halve()` function:

```{r half-measure, exercise=TRUE, error=TRUE, exercise.setup="sapply-solution"}
halve <- function(num){
  half <- num / 2
  return(half)
}

half_measure <- sapply(num_measurements, <name of function>)
half_measure
```

### Removing NAs

Our `num_measurements` data frame contains NAs, which denote missing data. This can cause problems in downstream analyses, so we can opt to remove them. First things first, though, we need to confirm if and how many NAs there are.

The function `is.na()` can take the entire data frame. For each value, it asks if it's an NA. If so, it outputs `TRUE`, otherwise, `FALSE`. 

```{r is-na, exercise=TRUE, exercise.setup="sapply-solution"}
is.na(num_measurements)
```

So how many NAs, or `TRUE`s, are there in each column? For a small data frame like this, you can try to count manually, but you can imagine how painful the task would be for a data frame with a thousand rows. 

Luckily, R can treat logicals like numbers. `TRUE` equates to 1 and `FALSE` to 0, so you can count how many `TRUE`s there are simply by adding them. The function `colSums()` calculates the sum of each column, displaying how many NAs there are:

```{r colsum, exercise=TRUE, exercise.setup="sapply-solution"}
colSums(is.na(num_measurements))
```

Now that we know how many NAs we have, we can move on to removing them. Let's start by removing all NAs using the `drop_na()` function:

```{r drop-na, exercise=TRUE, exercise.setup="sapply-solution"}
drop_na(num_measurements)
```

Wait, what happened? How did we lose all but two of our data points? As it turns out, when `drop_na()` finds one NA in the row, it removes the entire row. To preserve data, we can opt to only remove NAs with rows in specified columns. For example, if we only wanted to remove rows with NAs in the circumference column:

```{r drop-na2, exercise=TRUE, exercise.setup="sapply-solution"}
drop_na(num_measurements, circumference)
```


