---
title: "Intro to R - Advanced"
author: "Andrew Wilson"
date: "04/02/2020"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(learnr)
library(educer)
library(tidyverse)

# Helper function to set path to images to "/images" etc.
setup_resources()
```

## Learning Objectives
 By the end of this tutorial, students should be able to:
 
 1. Distinguish between the different data types in R
 2. Convert the type and structure of data
 
## How to use this tutorial
This tutorial was made with learnr, which provides a simple environment to learn R. The main content of the lessons is on the right hand side of your screen.

![](/images/content_window.png){width=100%}

On the left hand side of the screen is a navigation menu that you can use to go back to previously completed sections.

![](/images/navigation_pane.png){width=100%}

When you're done with the content on your screen, click the button at the bottom that says "Next Topic" or "Continue".

![](/images/navigation_button.png){width=100%}

Sometimes you'll encounter interactive code sections in the tutorial. These boxes give you a space to write R code and practice what you're learning. You can run the code by clicking the "run code" button.

![](/images/interactive_code.png){width=100%}


## Functions
A function is a piece of code that takes at least one input and produces some sort of output. 

![](/images/function.png){width=100%}
Functions form the basis of programming and data science. Most functions have some restrictions about what data you can give them. This tutorial is focused on how R interprets different types and shapes of data, so that you can use function in R effectively.


## Basic Data Types
### Background
In English, we use a latin alphabet to form our words and the arabic number system for math. Many of the operations that we perform on numbers make absolutely no sense when working with letters and vice versa.

Similarly, R is able to perform different operations on different types of data. R accepts three main `types` of data:

  * "character" 
  * "double"
  * "logical"


You can find the type of data with the `typeof` function. 

### Character

An object with type *character* is treated like a word. Anything can be stored as character, but that limits the operations you can perform on the data. You can assign a character by using either single or double quotation marks. 

Try using the `typeof()` function to verify that my_char is a character.

```{r character_assignment, exercise = TRUE}
# Assign a character
my_char <- "Hello World!"

``` 

### Double
Data with type *double*  is simply numeric data. To assing a double, you enter numeric information (either numbers directly or other numeric variables) to the right of the assignment operator. Math operations take and produce data with type 'double'.

Math operations in R:

Operation | Symbol
- | -
Addition | +
Subtraction | -
Multipliation | *
Division | /
Exponents | ^


Math operations in R take double as input and produce double output. In the chunk below, use the math operations above to calculate the area of a circle with radius 2.
```{r double_assignment, exercise = TRUE}
pi <- 3.14
r <- 2
my_area <-  #put math here

my_area
typeof(pi)
typeof(my_area)
```

### Logical
Often, *logical* data isn't saved to the environment. Instead, it is often used inside of function calls (we'll use logical data in the data wrangling tutorials later on). Logical data takes either `TRUE` or `FALSE` as its value, but is usually assigned by comparing two variables or calling a function which checks if a condition is true.


```{r logical_operators, echo = FALSE}
df <- data.frame("Operator" = c(">", "<", ">=", "<=", 
                                "!=", "==", "!"),
                 "Meaning" = c("greater than", "less than", "greater than or equal", "less than or equal",
                               "not equal", "equal", "not"),
                 "Example" = c("1 > 0", "1 < 0", "1 >= 1", "1 <= 2", "1 != 1", "1 == 2", "!is.na(1)"),
                 "Returns" = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE))
knitr::kable(df)
```

Logical expressions can be combined to make new expressions using "and" and "or" operators. The "and" operator for R is `&`. If two logical expressions are combined with `&`, they *both* must evaluate to TRUE for R to return TRUE.


#TODO


The "or" operator in R is "|". When two logical expressions are combined with `|`, R will return TRUE if one or both of the expressions is true.

#TODO 

 
The current logical expression evaluates to TRUE. Write another logical expression that is FALSE.
```{r logical_data_assignment, exercise = TRUE}
# Use one of the operators in the table above to assign logical data to a variable
my_logical <- 1 >= 0

my_logical
```



### Exercises

```{r data_types_quiz, echo = FALSE}
quiz(
  question("What is the value of 5 > 10/2",
           answer("FALSE", correct = TRUE),
           answer("Error"),
           answer("TRUE")
           ),
  question("If I initialize x with the code: x -> \"3\", what is the type of x?",
           answer("'double'"),
           answer("'integer'"),
           answer("'numeric'"),
           answer("'character'", correct = TRUE))
)
```


## Data Structures
In data science, you rarely want to work with a single number, word, or condition. To help keep you organized, R has several different data structures, each with their own rules and uses.

### Vectors 
The most basic data structure in R is called a *vector*. A vector contains multiple elements with the same type. You can assign a vector with the function `c()`. You can have a vector of any `type`. 

```{r vector_assignment}
my_vect <- c(1, 2, 3, 4)
my_char_vect <- c("hello", "world")
```

You'll often want to know some basic information about your data without plotting or spending too much time writing code. There are several functions which you can use to summarize the contents of objects in R.

The function `length` tells you how many entries are in a vector and `summary` gives you some basic information, which depends on the type and structure of the data you run it on.

```{r vector_summaries}
# Number entries in an array
length(my_vect)

# Summary statistics
summary(my_vect)
```

You can add new elements to a vector using `c()` by including the vector as one of the elements.
```{r extend vector}
new_vect <- c(my_vect, 5, 6, 7)
new_vect
```

If you attempt to create a vector with data that has more than one data type, R will coerce all of the elements to same type without warning you. If there are any characters in the vector, everything else will be coerced to `character`.

```{r coercion_example}
mixed_vector_1 <- c(1, "2", 3)
mixed_vector_1
```

Notice how the output is in double quotation marks. This is one way R tells you that the entries are characters.

If you try to mix logical and doubles in a vector, the resulting vector will contain doubles with TRUE being coerced to 1 and FALSE being coerced to 0.

```{r logical_coercion}
mixed_vector_2 <- c(TRUE, 2, 3)
mixed_vector_2
```

#### Vector Exercises

```{r vector_exercises, exercise = TRUE}

```

### Matrices

Matrices are like vectors but in 2 dimensions. You will probably not encounter matrices in most R courses, because they are difficult to work with. Many of the functions in the `vegan` package which you will use in other tutorials produce matrices so it is good to be able to recognize them 

The first way to build a matrix is with the `matrix` function which has several arguments that allow you to set the shape of the matrix.

```{r matrix examples}
v1 <- c(1,2,3)
v2 <- c(4,5,6)
v3 <- c(7,8,9)

matrix(data = c(v1, v2, v3), nrow = 3)
```

You can also use `cbind` which combines the vectors as columns.
```{r  cbind_example}
cbind(v1, v2, v3)
```

Or you can use `rbind` which combines the vectors as rows.
```{r rbind_example}
rbind(v1, v2, v3)
```

Just like vectors, all of the data within a matrix must be the same type, so R will coerce all of the elements to a common type. Below is the first matrix example, but with `v2` as a character vector.

```{r matrix_coercion_example}

v1 <- c(1,2,3)
v2 <- c("4","5","6")
v3 <- c(7,8,9)

matrix(data = c(v1, v2, v3), nrow = 3)
```

Notice that in the output, all of the entries in the matrix are in quotation marks.

### Data Frames
A data frame is the most common way to store data in R, because columns can have different types of data. Most of the time, you will create data frames by reading files in from your computer with the `read_*()` family of functions from the tidyverse which will be introduced in a different tutorial.

Just like with vectors, there are a few functions which are helpful when looking at a data frame for the first time. 

```{r dataframe_setup, echo = FALSE}
my_df = geochemicals[1:10,]
```

There is a dataframe in this 
```{r dataframe_summary, exercise = TRUE, exercise.setup = "dataframe_setup"}

# Instead of length() use dim()
dim(my_df)

# But summary() still works
summary(my_df)
```



## Changing Data Structures and Types
One very common problem while coding in R is that the data is in the wrong format for the function you want to use. Sometimes data structure issues break your code and are relatively easy to catch. Other times, however, your code will run without issue and cause unexpected results. 

If you need to change the type or struture of an object, you can use the `as.*()` family of functions. A very common function is `as.numeric()` which tries to coerce data to something that can be used in mathmatical operations.

#example

### Exercise
The `cars` dataset has speed and stopping distances for cars. The goal of this exercise is to create distance vs. speed that should look like this:
```{r plot_example, echo = FALSE}
ggplot(cars, aes(speed, dist))+
    stat_summary(geom = "line")
```

```{r type_conversion_setup, echo = FALSE, message = FALSE}
speedplot <- function(df){
  ggplot(df, aes(speed, dist))+
    stat_summary(geom = "line")
}

cars$speed <- as.character(cars$speed)
```

For this exercise, one of the two columns in the `cars` dataset has been modified. Try running the chunk below to see what happens. Use `summary` or `typeof` to figure out what is wrong with the data frame and one of the `as.*` functions to fix the problem. Your final chart should look like the one above.
```{r type_conversion_exercise, exercise = TRUE, exercise.setup = "type_conversion_setup"}
# Your code here


## Don't touch this!!
speedplot(cars)
```

## Subsetting
Sometimes, you will want to look at just one column of a data frame or one element in a vector. 

To subset a vector, you can use square brackets with the index of the element that you want to return. The code below returns the 5th element of `new_vect`. Modify it to return the first element.

```{r subsetting_vectors}
new_vect[5]
```

You can subset data frames with the square brackets as well, using comma-separated values for row and column. Try to  find the 3rd item from the 2nd colum of `my_df`.
```{r subsetting_df_1, exercise = TRUE,  exercise.setup = "dataframe_setup"}
my_df[ , ]
```

Perhaps a more common way of subsetting a data frame is to return a column from the data frame. The operator to perform this function is `$`. You don't have to type the name of the column out, you can press the first letter and then TAB and it will automatically complete as much of the column name as it can.

```{r subsetting_df_2, exercise = TRUE, exercise.setup = "dataframe_setup"}
#Try using tab completion to select a column from my_df
my_df$
```

*Note*: you can also return a column with square bracket notation, but the column will be a data frame with one column.

```{r subsetting_df_3}
geochemicals[,1]
```
