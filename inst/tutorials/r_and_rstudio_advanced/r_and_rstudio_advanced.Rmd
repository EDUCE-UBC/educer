---
title: "Intro to R - Advanced"
author: "Andrew Wilson"
date: "04/02/2020"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(learnr)
library(educer)
library(tidyverse)

# Helper function to set path to images to "/images" etc.
setup_resources()
```
## Learning Objectives


## Functions
A function is a piece of code that takes at least one input and produces some sort of output. 

```{r function_image, echo = FALSE, out.width="60%"}
knitr::include_graphics("/images/function.png")
```

Functions form the basis of programming and data science. Most functions have some restrictions about what data you can give them. This tutorial is focused on how R interprets different types and shapes of data, so that you can use function in R effectively.


## Basic Data Types
### Background
In English, we use a latin alphabet to form our words and the arabic number system for math. Many of the operations that we perform on numbers make absolutely no sense when working with letters and vice versa.

Similarly, R is able to perform different operations on different types of data. R accepts three main `types` of data:

  * "character" 
  * "double"
  * "logical"


You can find the type of data with the `typeof` function. 

### Character

An object with type *character* is treated like a word. Anything can be stored as character, but that limits the operations you can perform on the data. You can assign a character by using either single or double quotation marks. Try using the `typeof()` function to verify that my_char is a character.

```{r character_assignment, exercise = TRUE}
# Assign a character
my_char <- "Hello World!"


``` 

### Double
Data with *double* type is simply numeric data. To assing a double, you just enter numeric information (either numbers directly or other numeric variables) to the right of the assignment operator. Math operations take and produce data with type 'double'.

Arithemetic operators you can use in R are

```{r double_assignment}
# Assign a double
pi <- 3.14
r <- 2
my_area <- pi * (r^2)

typeof(pi)
typeof(my_area)
```

### Logical
Often, *logical* data isn't saved to the environment. Instead, it is often used inside of function calls (we'll use logical data in the data wrangling tutorials later on). Logical data takes either `TRUE` or `FALSE` as its value, but is usually assigned by comparing two variables or calling a function which checks if a condition is true.


```{r logical_operators, echo = FALSE}
df <- data.frame("Operator" = c(">", "<", ">=", "<=", 
                                "!=", "==", "&", "|",
                                "%in%", "!"),
                 "Meaning" = c("greater than", "less than", "greater than or equal", "less than or equal",
                               "not equal", "equal", "and", "or", "is found in", "not"),
                 "Example" = c("1 > 0", "1 < 2", "1 >= 1", "1 <= 2", "1 != 1.5", "1 == 1", "1 < 2 & 1 > 0",
                               "1 > 0 | 1 < 1", "1 %in% c(1, 2, 3)", "!is.na(1)"))
knitr::kable(df)
```

  
```{r variable_assignment, exercise = TRUE}
# Use one of the operators in the table above to assign logical data to a variable


```

### Type coercion



### Exercises

Create 3 variables: One `double`, one `logical`, and one `character`. Try adding your variables together using the `+` operator.
```{r initialize_types_exercise, exercise = TRUE, exercise.lines = 5}
# Create a 'double' variable

# Create a 'logical' variable

# Create a 'character' variable


# Add your variables together

```

```{r data_types_quiz, echo = FALSE}
quiz(
  question("What is the value of TRUE + 3?",
           answer("4", correct = TRUE),
           answer("3"),
           answer("Error"),
           answer("TRUE")
           ),
  question("If I initialize x with the code: x -> \"3\", what is the type of x?",
           answer("'double'"),
           answer("'integer'"),
           answer("'numeric'"),
           answer("'character'", correct = TRUE))
)
```

## Data Structures
In data science, you rarely want to work with a single number, word, or condition. To help keep you organized, R has several different data structures, each with their own rules and uses.

### Vectors 
The most basic data structure in R is called a *vector*. A vector contains multiple elements with the same type. You can assign a vector with the function `c()`. You can have a vector of any `type`.

```{r vector_assignment}
my_vect <- c(1, 2, 3, 4)
my_char_vect <- c("hello", "world")
```


You'll often want to know some basic information about your data without plotting or spending too much time writing code. There are several functions which you can use to summarize the contents of objects in R.

The function `length` tells you how many entries are in a vector and `summary` gives you some basic information, which depends on the type and structure of the data you run it on.

```{r vector_summaries}
# Number entries in an array
length(my_vect)

# Summary statistics
summary(my_vect)
```

You can add new elements to a vector using `c()` by including the vector as one of the elements.
```{r extend vector}
new_vect <- c(my_vect, 5, 6, 7)
new_vect
```

#### Vector Exercises
Initialize 3 vectors with :
```{r vector_exercises, exercise = TRUE}

```

### Matrices
Matrices are like vectors but in 2 dimensions. You will probably not encounter matrices in most R courses, because they are difficult to work with. Many of the functions in the `vegan` package which you will use in other tutorials produce matrices so it is good to be able to recognize them 

You can initialize a matrix using the `matrix()` function or by combining vectors with the functions row-wise or column-wise with `rbind()` and `cbind()` respectively.

```{r matrix examples}
v1 <- c(1,2,3)
v2 <- c(1,3,4)
v3 <- c(3,4,5)

matrix(data = c(v1, v2, v3), nrow = 3)
cbind(v1, v2, v3)
rbind(v1, v2, v3)
```

### Data Frames
A data frame is the most common way to store data in R. Most of the time, you will create data frames by reading files in from your computer with the `read_*()` family of functions from the tidyverse which will be introduced in a different tutorial.

Just like with vectors, there are a few functions which are helpful when looking at a data frame for the first time. 

```{r dataframe_summary, exercise = TRUE}

# Use square bracket notation to assign the first 10 rows of geochemicals to my_df
my_df <- geochemicals[]

# Instead of length() use dim()
dim(my_df)

# But summary() still works
summary(my_df)
```


## Changing Data Structures and Types
One very common problem while coding in R is that the data is in the wrong format for the function you want to use. Sometimes data structure issues break your code and are relatively easy to catch. Other times, however, your code will run without issue and cause unexpected results. 

If you need to change the type of an object, you can use the `as.*()` family of functions. For example, if you want to convert the data.frame from the previous page to a matrix, you can use `as.matrix()`. 

```{r as.family}
new_mat <- as.matrix(new_df)
new_mat
```

### Exercise
The `cars` dataset has speed and stopping distances for cars. The function `speedplot` produces a plot pf stopping distance vs. speed that should look like this:

```{r, echo = FALSE}
speedplot <- function(df){
  ggplot(df, aes(speed, dist))+
    stat_summary(geom = "line")
}

speedplot(cars)
cars$speed <- as.character(cars$speed)
```

For this exercise, one of the two columns in the `cars` dataset has been modified. Try running the chunk below to see what happens. Use `summary` or `typeof` to figure out what is wrong with the data frame and one of the `as.*` functions to fix the problem. Your final chart should look like the one above.
```{r type_conversion_exercise, exercise = TRUE}

# Your code here
speedplot(cars)
```
## Subsetting
Sometimes, you will want to look at just one column of a data frame or one element in a vector. 

To subset a vector, you can use square brackets with the index of the element that you want to return. The code below returns the 5th element of `new_vect`. Modify it to return the first element.

```{r subsetting_vectors, exercise = TRUE}
new_vect[5]
```

You can subset data frames with the square brackets as well, using comma-separated values for row and column. Try to  find the 3rd item from the 2nd colum of `new_df`.
```{r subsetting_df_1, exercise = TRUE}
new_df[ , ]
```

Perhaps a more common way of subsetting a data frame is to return a column from the data frame. The operator to perform this function is `$`.
```{r subsetting_df_2}
new_df$vect1
```


*Note*: you can also return a column with square bracket notation, but the column will be a data frame with one column.
```{r subsetting_df_3}
new_df[,1]
```
