---
title: "Advanced R and RStudio fundamentals"
author: "Andrew Wilson"
date: "04/02/2020"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: In-detail description will follow.
---

```{r setup, include=FALSE}
# General learnr setup
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
library(educer)
# Helper function to set path to images to "/images" etc.
setup_resources()

# Tutorial specific setup
library(tidyverse)
```

## Learning Objectives

 By the end of this tutorial, students should be able to:
 
 - Distinguish between the different data types in R.
 - Convert the type and structure of data.
 
## How to use this tutorial

This tutorial was made with learnr, which provides a simple environment to learn R. The main content of the lessons is on the right hand side of your screen.

![](/images/content_window.png){width=100%}

On the left hand side of the screen is a navigation menu that you can use to go back to previously completed sections.

![](/images/navigation_pane.png){width=100%}

When you're done with the content on your screen, click the button at the bottom that says "Next Topic" or "Continue".

![](/images/navigation_button.png){width=100%}

Sometimes you'll encounter interactive code sections in the tutorial. These boxes give you a space to write R code and practice what you're learning. You can run the code by clicking the "run code" button.

![](/images/interactive_code.png){width=100%}

Code chunks are ungraded, so you don't need to stress about getting things right the first time. Use the `help()` function or check [StackExchange](https://stackexchange.com/) if you get stuck.

Here is an interactive code chunk with some code for you to run:

```{r first-chunk, exercise = TRUE}
print("Hello, World!", quote = FALSE)
```



## Functions

A function is a piece of code that takes at least one input and produces some sort of output. 

![](/images/function.png){width=100%}
Functions form the basis of programming and data science. Most functions have some restrictions about what data you can give them. This tutorial is focused on how R interprets different types and shapes of data, so that you can use functions in R effectively.



## Basic Data Types

### Background
In English, we use a latin alphabet to form our words and the arabic number system for math. Many of the operations that we perform on numbers make absolutely no sense when working with letters and vice versa.

Similarly, R is able to perform different operations on different types of data. R accepts three main types of data:

- character
- double
- logical


You can find the type of a variable with the `typeof()` function. 

### Character

An object with type *character* is treated like a word. Anything can be stored as character, but doing so limits the operations you can perform on the data. You can assign a character by using either single or double quotation marks. 

Try using the `typeof()` function to verify that my_char is a character.

```{r character-assignment, exercise = TRUE}
# Assign a character
my_char <- "Hello World!"

``` 

### Double

Data with type *double*  is simply numeric data. To assing a double, you enter numeric information (either numbers directly or other numeric variables) to the right of the assignment operator. Math operations take and produce data with type 'double'.

Math operations in R:

Operation | Symbol
--- | ---
- | -
Addition | +
Subtraction | -
Multipliation | *
Division | /
Exponents | ^

Math operations in R take double as input and produce double output. In the chunk below, use math operations to calculate the area of a circle with radius 2.

```{r double-assignment, exercise = TRUE}
pi <- 3.14
r <- 2
my_area <-  #put math here

my_area
typeof(pi)
typeof(my_area)
```

### Logical

Often, *logical* data isn't saved to the environment. Instead, it is often used inside of function calls (we'll use logical data in the data wrangling tutorials later on). Logical data takes either `TRUE` or `FALSE` as its value, but is usually assigned by comparing two variables or calling a function which checks if a condition is true.

```{r logical-operators, echo = FALSE}
df <- data.frame(
  "Operator" = c(">", "<", ">=", "<=", 
                 "!=", "==", "!"),
  "Meaning"  = c("greater than", "less than", "greater than or equal",
                 "less than or equal", "not equal", "equal", "not"),
  "Example"  = c("1 > 0", "1 < 0", "1 >= 1", "1 <= 2", "1 != 1", "1 == 2",
                 "!is.na(1)"),
  "Returns"  = c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE))
knitr::kable(df)
```

Logical expressions can be combined to make new expressions using "and" and "or" operators. The "and" operator for R is `&`. If two logical expressions are combined with `&`, they *both* must evaluate to `TRUE` for R to return `TRUE`.

#TODO

The "or" operator in R is `|`. When two logical expressions are combined with `|`, R will return `TRUE` if one or both of the expressions is true.

#TODO 

To summarize, refer to this table:

```{r combinatorial-operators, echo = FALSE}
df <- data.frame("1"       = c(TRUE, TRUE, FALSE, FALSE),
                 "2"       = c(TRUE, FALSE, TRUE, FALSE),
                 "AND (&)" = c(TRUE, FALSE, FALSE, FALSE),
                 "OR (|)"  = c(TRUE, TRUE, TRUE, FALSE))
knitr::kable(df)
```

The current logical expression evaluates to `TRUE`. Write another logical expression that is `FALSE`. Try combining the two expressions using `&` and `|`.

```{r logical-data-assignment, exercise = TRUE}
# Use one of the operators in the table above to assign logical data to a variable
logical_1 <- 1 >= 0
logical_1

logical_2 <- #Put an expression here
logical_2
```

### Exercises

```{r data-types-quiz, echo = FALSE}
quiz(
  question("What is the value of 5 > 10/2",
           answer("FALSE", correct = TRUE),
           answer("Error"),
           answer("TRUE")
           ),
  question("If I initialize x with the code: x -> \"3\", what is the type of x?",
           answer("double"),
           answer("integer"),
           answer("numeric"),
           answer("character", correct = TRUE))
)
```



## Data Structures

In data science, you rarely want to work with a single number, word, or condition. To help keep you organized, R has several different data structures, each with their own rules and uses.

### Vectors 

The most basic data structure in R is called a *vector*. A vector contains multiple elements with the same type. You can assign a vector with the function `c()`. You can have a vector of any type. In the code chunk below, assign character elements to `my_char_vect` using `c()`.

```{r vector-setup, echo = FALSE}
my_vect <- c(1, 2, 3, 4)
bool_vect <- my_vect > 2
depths <- unique(geochemicals$Depth) * 1000
```

```{r vector-assignment, exercise = TRUE, exercise.setup = "vector-setup"}
my_vect <- c(1, 2, 3, 4)
my_char_vect <- 
```

You'll often want to know some basic information about your data without plotting or spending too much time writing code. There are several functions which you can use to summarize the contents of objects in R.

The function `length()` tells you how many entries are in a vector and `summary(`)) gives you some basic information, which depends on the type and structure of the data that you input. 

Use `length()` and `summary()` to quickly assess the contents of `my_vect`.

```{r vector-summaries, exercise = TRUE, exercise.setup = "vector-setup"}
# Number entries in my_vect

# Summary statistics

```

You can add new elements to a vector using `c()` by including the vector as one of the elements. Use `length()` to find the length of new_vect.

```{r extend-vector, exercise = TRUE, exercise.setup = "vector-setup"}
new_vect <- c(my_vect, 5, 6, 7)
new_vect
```

If you attempt to create a vector with data that has more than one data type, R will coerce all of the elements to same type without warning you. If there are any characters in the vector, everything else will be coerced to character.

In the code chunk below, there is a vector containing both numbers and characters. Use `typeof()` to verify that the vector has been coerced to a character vector.

```{r coercion-example, exercise = TRUE}
mixed_vector_1 <- c(1, "2", 3)
mixed_vector_1
```

Notice how the output is in double quotation marks. This is one way R tells you that the entries are characters.

If you try to mix logical and double elements in a vector, the resulting vector will contain all doubles with `TRUE` being coerced to `1` and `FALSE` being coerced to `0`. 

```{r logical-coercion, exercise = TRUE}
mixed_vector_2 <- c(TRUE, 2, 3)
mixed_vector_2
```

A common use for coercing logical data to double is when you want to count how many elements in a vector match a certain condition. 

For example, if I wanted to know how many numbers in `my_vect` are greater than 2, I could generate a vector of logical data by running:

```{r counting-true-1, exercise = TRUE, exercise.setup = "vector-setup"}
bool_vect <- my_vect > 2
bool_vect
```

Since `TRUE` gets coerced to `1` and `FALSE` gets coerced to `0`, you can count how many elements in the vector evaluated to TRUE with the function `sum()`.

```{r counting-true-2, exercise = TRUE, exercise.setup = "vector-setup"}
sum(bool_vect)
```

You can combine these two expressions and run them together by placing the logical expression inside of `sum()`.

```{r counting-true-3, exercise = TRUE, exercise.setup = "vector-setup"}
sum(my_vect > 2)
```

#### Vector Exercise

The data for these tutorials comes from a study of ocean microbes. Measurements were taken at different depths which are stored in a vector called `depths`. Follow the instructions in the comments in the code chunk below.

```{r vector-exercises, exercise = TRUE, exercise.setup = "vector-setup"}
# How many depths were studied?

# Convert the depths to kilometres

# How many depths are greater than 100 metres

```

### Matrices

Matrices are like vectors but in 2 dimensions. You will probably not encounter matrices in most R courses, because they are difficult to work with. Many of the functions in the "vegan" package which you will use in other tutorials produce matrices so it is good to be able to recognize them.

The first way to build a matrix is with the `matrix()` function which has several arguments that allow you to set the shape of the matrix.

```{r matrix-setup, echo = FALSE}
v1 <- c(1,2,3)
v2 <- c(4,5,6)
v3 <- c(7,8,9)
```

```{r matrix-examples, exercise = TRUE, exercise.setup = "matrix-setup"}
v1 <- c(1,2,3)
v2 <- c(4,5,6)
v3 <- c(7,8,9)

matrix(data = c(v1, v2, v3), nrow = 3)
```

You can also use `cbind()` which combines the vectors as columns.

```{r  cbind-example, exercise = TRUE, exercise.setup = "matrix-setup"}
cbind(v1, v2, v3)
```

Or you can use `rbind` which combines the vectors as rows.

```{r rbind-example, exercise = TRUE, exercise.setup = "matrix-setup"}
rbind(v1, v2, v3)
```

Just like vectors, all of the data within a matrix must be the same type, so R will coerce all of the elements to a common type. Below is the first matrix example, but with `v2` as a character vector.

```{r matrix-coercion-example}

v1 <- c(1,2,3)
v2 <- c("4","5","6")
v3 <- c(7,8,9)

matrix(data = c(v1, v2, v3), nrow = 3)
```

Notice that in the output, all of the entries in the matrix are in quotation marks.

### Data Frames

As we've just seen, vectors and matrices can only store one type of data. In most circumstances, however, you'll want to store data with different types together. The data structure that R uses to store multiple data types together is a data frame. Data frames consist of column vectors joined together. Because columns are vectors, every entry in the column must have the same type, but you can have columns with different types in the same data frame.

```{r data-frame_example, echo = FALSE}
knitr::kable(geochemicals[1:10,1:5])
```

Most of the time, you will create data frames by reading files in from your computer with the `read_*()` family of functions from the tidyverse which will be introduced in a different tutorial.

Just like with vectors, there are a few functions which are helpful when looking at a data frame for the first time. 

```{r dataframe-setup, echo = FALSE}
my_df = geochemicals[1:10,]
```

```{r dataframe-summary, exercise = TRUE, exercise.setup = "dataframe-setup"}

# Instead of length() use dim()
dim(my_df)

# But summary() still works
summary(my_df)
```


## Subsetting
Sometimes, you will want to look at just one column of a data frame or one element in a vector. 

To subset a vector, you can use square brackets with the index of the element that you want to return. The code below returns the 2nd element of `my_vect`. Modify it to return the first element.

```{r subsetting-vectors, exercise = TRUE, exercise.setup = "vector-setup"}
my_vect[2]
```

You can subset data frames with the square brackets as well, using comma-separated values for row and column. Try to  find the 3rd item from the 2nd colum of `my_df`.
```{r subsetting-df-1, exercise = TRUE,  exercise.setup = "dataframe-setup"}
my_df[ , ]
```

Perhaps a more common way of subsetting a data frame is to return a column from the data frame. The operator to perform this function is `$`. You don't have to type the name of the column out, you can press the first letter and then TAB and it will automatically complete as much of the column name as it can.

```{r subsetting-df-2, exercise = TRUE, exercise.setup = "dataframe-setup"}
#Try using tab completion to select a column from my_df
my_df$
```

*Note*: you can also return a column with square bracket notation, but the column will be a data frame with one column.

```{r subsetting-df-3}
geochemicals[,1]
```


## Changing Data Structures and Types
One very common problem while coding in R is that the data is in the wrong format for the function you want to use. Sometimes data structure issues break your code and are relatively easy to catch. Other times, however, your code will run without issue and cause unexpected results. 

If you need to change the type or struture of an object, you can use the `as.*()` family of functions. A very common function is `as.numeric()` which tries to coerce data to something that can be used in mathmatical operations.

Try using `as.numeric()` to create a numeric vector from this character vector:

```{r coercion-exercise, exercise = TRUE}
char_vect <- c("1", "2", "3")
numeric_vect <- #Put code here
```

### Exercise
The `cars` dataset has speed and stopping distances for cars. The goal of this exercise is to create distance vs. speed that should look like this:

```{r plot-example, echo = FALSE, message = FALSE}
ggplot(cars, aes(speed, dist)) +
    stat_summary(geom = "line")
```


```{r type-conversion-setup, echo = FALSE, message = FALSE}
speedplot <- function(df){
  ggplot(df, aes(speed, dist)) +
    stat_summary(geom = "line")
}

cars$speed <- as.character(cars$speed)
```

For this exercise, one of the two columns in the `cars` dataset has been modified. Try running the chunk below to see what happens. Use `summary` or `typeof` to figure out what is wrong with the data frame and one of the `as.*` functions to fix the problem. Your final chart should look like the one above.

```{r type_conversion-exercise, exercise = TRUE, exercise.setup = "type-conversion-setup", message = FALSE}
# Your code here


## Don't touch this!!
speedplot(cars)
```

